# -*- coding: utf-8 -*-
"""feedback.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aTiGw9T83iNLWryx0fa2MFx_jSVNbMAm
"""

import pandas as pd
import numpy as np

import pandas as pd
import io

# 파일 로드 (data2.csv) -> 수정 : data_200_200_30.csv 로드
try:
    # df = pd.read_csv('data2.csv')
    df = pd.read_csv('data_200_200_30.csv')
except FileNotFoundError:
    print("파일을 찾을 수 없습니다. 파일 경로를 확인해주세요.")
    exit()

# 'action' 컬럼의 문자열 값을 정수 리스트로 변환
# 쉼표로 구분된 문자열을 파싱하고 정수로 변환합니다.
df['action_list'] = df['action'].apply(lambda x: [int(i) for i in str(x).split(',')])

# 결과를 담을 빈 리스트 초기화
explicit_feedback_list = []
implicit_feedback_list = []

# 데이터프레임을 행 단위로 순회
for index, row in df.iterrows():
    user_id = row['user_id']
    step = row['step']
    reward = row['reward']
    actions = row['action_list']

    # 해당 행의 추천 아이템 개수 (응답 컬럼셋의 인덱스 상한)
    num_actions = len(actions)

    for i, item_id in enumerate(actions):
        # i는 0부터 num_actions - 1까지의 인덱스로, resp_i 컬럼셋에 대응됩니다.
        prefix = f'resp_{i}_'

        # --- 1. Explicit Feedback 추출 ---
        # Explicit: user_id, item_id, step, reward
        # reward는 해당 user/step의 모든 action item에 동일하게 적용됩니다.
        responsed = row.get(prefix + 'click_doc_id', 0)
        if responsed != -1:
            explicit_feedback_list.append({
                'user_id': user_id,
                'item_id': item_id,
                'step': step,
                'reward': reward
            })
        else:
            explicit_feedback_list.append({
                'user_id': user_id,
                'item_id': item_id,
                'step': step,
                'reward': 0
            })

        # --- 2. Implicit Feedback 추출 ---
        # Implicit: user_id, item_id, step, response

        # 응답 컬럼이 있는지 확인하고 값을 가져옵니다.
        # 컬럼이 없을 경우 (예: action 개수보다 응답 컬럼셋이 부족한 경우) 기본값 0을 사용
        clicked = row.get(prefix + 'click', 0)
        watched = row.get(prefix + 'watch', 0)
        liked = row.get(prefix + 'liked', 0)

        # response 판단: click, watch, liked 중 하나라도 1이면 1, 아니면 0
        # 논리합(OR) 연산을 사용하여 판단
        response = 1 if responsed != -1 and (clicked == 1 or watched != 0 or liked != 0) else 0

        implicit_feedback_list.append({
            'user_id': user_id,
            'item_id': item_id,
            'step': step,
            'response': response
        })

# 결과 데이터프레임 생성
explicit_df = pd.DataFrame(explicit_feedback_list)
implicit_df = pd.DataFrame(implicit_feedback_list)

# 결과 확인
print("--- Explicit Feedback (일부) ---")
print(explicit_df.head(10))
print(f"\n총 Explicit Feedback 수: {len(explicit_df)}")
print("\n--- Implicit Feedback (일부) ---")
print(implicit_df.head(10))
print(f"\n총 Implicit Feedback 수: {len(implicit_df)}")

# --- 3. User-Item Matrix 생성 (Explicit) ---

# Explicit 피드백 데이터프레임 (explicit_df)을 사용하여 User-Item Matrix 생성
# 인덱스: user_id, 컬럼: item_id, 값: reward
# reward 값이 NaN(결측값)인 경우 (사용자가 해당 아이템에 대해 피드백을 주지 않은 경우) 0으로 채웁니다.
explicit_matrix = explicit_df.pivot_table(
    index='user_id',
    columns='item_id',
    values='reward',
    aggfunc='max',  # 최댓값으로 집계
    fill_value=0  # 피드백이 없는 경우 0으로 채움
)

# --- 4. User-Item Matrix 생성 (Implicit) ---

# Implicit 피드백 데이터프레임 (implicit_df)을 사용하여 User-Item Matrix 생성
# 인덱스: user_id, 컬럼: item_id, 값: response
# response 값이 NaN인 경우 (사용자가 해당 아이템에 대해 상호작용하지 않은 경우) 0으로 채웁니다.
# Implicit feedback에서는 'response'가 0 또는 1이므로, pivot_table을 통해 aggregation을 하면
# 상호작용이 없는 경우는 자동으로 NaN이 됩니다.
implicit_matrix = implicit_df.pivot_table(
    index='user_id',
    columns='item_id',
    values='response',
    aggfunc='max', # 최댓값으로 집계 (1 또는 0이 되도록 보장)
    fill_value=0  # 상호작용이 없는 경우 0으로 채움
)

# --- 결과 확인 ---
print("\n--- Explicit User-Item Matrix (일부) ---")
print(explicit_matrix.head())
print(f"\nExplicit Matrix 크기: {explicit_matrix.shape}")

print("\n--- Implicit User-Item Matrix (일부) ---")
print(implicit_matrix.head())
print(f"\nImplicit Matrix 크기: {implicit_matrix.shape}")